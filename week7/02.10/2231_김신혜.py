''' 2231번 분해합
A의 분해합은 N(A과 A을 이루는 각 자리수의 합)
A의 분해합이 B인 경우, B을 A의 생성자라 한다.

A(245) -> N(256(=245+2+4+5))분해합
A(245)생성자 <- N(256)

A -> N(분해합)
A(생성자) <- N

생성자가 없을 수도, 생성자가 여러 개인 자연수도 있을 수 있다.
자연수 N(분해합)이 주어졌을 때, B의 가장 작은 생성자(A) 구하기

입력
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

출력
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.'''
"""216"""
#198


'''
100의 자리의 경우 
숫자의 길이는 3이되고 각 자리마다 9가 들어갔을 때 최댓값을 제외하여 계산하기로 한다. 
999 (999+9+9+9)
'''
lst = []    # 분해합 후보 리스트
lst2 = []   # 분해합에 대당하는 리스트
N = int(input())
length = len(str(N))    # 숫자의 길이를 구한다.

# 숫자가 100의 자리 이상일 경우를 고려해
# 각 자리에 9가 들어갔을 때의 최댓값 만큼 경우를 탐색
for n in range(1,length*9+1):   

    # 원래 입력받은 분해합 정수에서 1씩 줄여가면서 탐색
    number = N - n

    # 먼저 리스트에 탐색할 정수(생성자 후보)를 담는다.
    lst.append(number)

    while True:
        # 탐색할 정수(생성자 후보)를 10으로 나누면서 몫과 나머지를 구한다.
        a = divmod(number, 10)
        # 나머지를 리스트에 담는다.
        lst.append(a[1])
        # 몫은 다시 탐색할 숫자로 변경
        number = a[0]

        # 몫이 0이 될때까지 반복하여 나머지를 계속해서 리스트에 모은다.
        # 몫이 0이 나오면 break 
        if a[0] == 0:
            break
    
    # lst 속의 숫자의 합이 원래 입력값과 완전히 동일하다면 
    # 가장 앞에 있는 인덱스[0]의 수가 생성자에 해당하기 때문에 두번째 리스트에 모아둔다.
    if sum(lst) == N:
        lst2.append(lst[0])
        print('3 : ', n, lst)
    
    lst.clear() # 탐색이 끝나면 lst를 비운다.
print(min(lst2))    # 두번째 리스트에서 가장 작은 생성자를 출력