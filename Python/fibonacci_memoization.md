# 피보나치 수열로 알아보는 메모이제이션의 필요

피보나치 수열은 첫 번째 항과 두번째 항을 더해 세번째 항을 구하는 수열이다.

a_1 = 1
a_2 = 1
a_3 = a_1 + a_2
a_n = a\*(n-1) + a\_(n-2)

```python
# 파이썬 피보나치수열 공식

def f(n):
  if n == 1:
    return 1
  elif n == 2:
    return 1
  else:
    return f(n - 1) + f(n - 2)

# 1 : f(1) = 1
# 1 : f(2) = 1
# 2 : f(3) = f(2) + f(1)
# 3 : f(4) = f(3) + f(2)
# 5 : f(5) = f(4) + f(3)
```

![피보나치 수열 트리구조](https://blog.kakaocdn.net/dn/ufkZW/btraTbd0GQF/kUnH9bbEB4UK5rK59OGc4K/img.png)

트리를 그림으로 그려보면 불 필요한 연산이 반복되는 것을 확인할 수 있다.\
그래서 피보나치수열을 포함한 모든 재귀함수는 input이 10이상일 때부터 연산의 속도가 엄청나게 느려진다.

현업이나 코딩테스트에서는 이런 재귀함수의 개념이 거의 쓰이지 않는다고 하지만, BFS와 DFS의 구조를 이해하기 위해 먼저 생각해보아야할 불편함인 것 같다.

한번 계산한 결과를 메모해 놓고, 다음에 똑같은 연산을 만나면 메모한 내용을 꺼내오면 연산의 시간을 효율적으로 바꿀 수 있다.

# 메모이제이션 사용법

메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. `동적 계획법`의 핵심이 되는 기술이다.<sub>[위키백과](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)</sub>

```python
memo = {}
def f(n):
  if n == 1:
    return 1
  elif n == 2:
    return 1
  else:
    # 원래 출력하던 수식을 step이라는 변수로 지정하여 딕셔너리에 메모하고 출력도 한다.
    step = f(n - 1) + f(n - 2)
    memo[n] = step
    return step
```

1. memo라는 딕셔너리를 만들고
2. 피보나치수열의 값이 구해지는 단계 step에서
3. memo에 기록하고 출력하기를 반복한다.
